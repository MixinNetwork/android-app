package one.mixin.android.util

import cafe.cryptography.ed25519.Ed25519PrivateKey
import net.i2p.crypto.eddsa.EdDSAPrivateKey
import net.i2p.crypto.eddsa.EdDSAPublicKey
import net.i2p.crypto.eddsa.spec.EdDSAPrivateKeySpec
import net.i2p.crypto.eddsa.spec.EdDSAPublicKeySpec
import one.mixin.android.crypto.Base64
import one.mixin.android.crypto.ed25519
import one.mixin.android.crypto.generateEd25519KeyPair
import one.mixin.android.crypto.getPublicKey
import one.mixin.android.crypto.privateKeyToCurve25519
import one.mixin.android.crypto.publicKeyToCurve25519
import java.security.SecureRandom
import kotlin.test.Test

class CryptoUtilTest {

    @Test
    fun `test curve25519 conversion`() {
        val public = byteArrayOf(147.toByte(), 193.toByte(), 19.toByte(), 201.toByte(), 96.toByte(), 200.toByte(), 216.toByte(), 248.toByte(), 19.toByte(), 54.toByte(), 49.toByte(), 150.toByte(), 150.toByte(), 167.toByte(), 41.toByte(), 75.toByte(), 87.toByte(), 242.toByte(), 28.toByte(), 199.toByte(), 153.toByte(), 217.toByte(), 6.toByte(), 224.toByte(), 84.toByte(), 169.toByte(), 210.toByte(), 80.toByte(), 186.toByte(), 202.toByte(), 128.toByte(), 201.toByte())
        val seed = byteArrayOf(126.toByte(), 51.toByte(), 73.toByte(), 128.toByte(), 30.toByte(), 5.toByte(), 236.toByte(), 244.toByte(), 27.toByte(), 127.toByte(), 26.toByte(), 150.toByte(), 49.toByte(), 250.toByte(), 179.toByte(), 252.toByte(), 107.toByte(), 36.toByte(), 94.toByte(), 118.toByte(), 231.toByte(), 79.toByte(), 230.toByte(), 175.toByte(), 74.toByte(), 217.toByte(), 163.toByte(), 61.toByte(), 162.toByte(), 214.toByte(), 235.toByte(), 156.toByte())
        val targetPrivate = byteArrayOf(232.toByte(), 23.toByte(), 164.toByte(), 168.toByte(), 212.toByte(), 159.toByte(), 250.toByte(), 121.toByte(), 48.toByte(), 244.toByte(), 252.toByte(), 13.toByte(), 183.toByte(), 100.toByte(), 82.toByte(), 162.toByte(), 219.toByte(), 106.toByte(), 10.toByte(), 171.toByte(), 30.toByte(), 240.toByte(), 31.toByte(), 208.toByte(), 91.toByte(), 201.toByte(), 15.toByte(), 179.toByte(), 136.toByte(), 192.toByte(), 210.toByte(), 87.toByte())
        val targetPublic = byteArrayOf(159.toByte(), 128.toByte(), 169.toByte(), 96.toByte(), 138.toByte(), 29.toByte(), 242.toByte(), 209.toByte(), 248.toByte(), 250.toByte(), 1.toByte(), 148.toByte(), 133.toByte(), 194.toByte(), 107.toByte(), 237.toByte(), 154.toByte(), 18.toByte(), 40.toByte(), 50.toByte(), 51.toByte(), 58.toByte(), 81.toByte(), 213.toByte(), 200.toByte(), 152.toByte(), 8.toByte(), 126.toByte(), 7.toByte(), 140.toByte(), 6.toByte(), 47.toByte())

        val publicKey = EdDSAPublicKey(EdDSAPublicKeySpec(public, ed25519))

        val curve25519PrivateKey = privateKeyToCurve25519(seed)
        assert(curve25519PrivateKey.contentEquals(targetPrivate))
        val curve25519PublicKey = publicKeyToCurve25519(publicKey)
        assert(curve25519PublicKey.contentEquals(targetPublic))
    }

    @Test
    fun `test curve25519 keys versatility`() {
        val keyPair = generateEd25519KeyPair()
        val seed = (keyPair.private as EdDSAPrivateKey).seed
        val privateKey = Ed25519PrivateKey.fromByteArray(seed)
        assert(privateKey.derivePublic().toByteArray().contentEquals(keyPair.getPublicKey()))
    }

    @Test
    fun `test Ed25519 keys versatility`() {
        val privateKey = Ed25519PrivateKey.generate(SecureRandom())
        val privateSpec = EdDSAPrivateKeySpec(privateKey.toByteArray(), ed25519)
        val edPublicKey = EdDSAPublicKey(EdDSAPublicKeySpec(privateSpec.a, ed25519))
        val publicKeyBytes = publicKeyToCurve25519(edPublicKey)
        assert(privateKey.derivePublic().toByteArray().contentEquals(publicKeyBytes))
    }

    private fun testCurve25519(bytes: ByteArray) {
        assert(verifyPubkey(bytes))
    }

    @Test
    fun `test curve25519`() {
        repeat(10000) {
            val privateKey = Ed25519PrivateKey.generate(SecureRandom())
            val publicKey = privateKey.derivePublic()
            testCurve25519(publicKey.toByteArray())
        }

        // Generated by dart
        listOf(
            "OSyRgcjSLPMtBJFF6MqP6iHFXdCisZTlEjdPyhP+biY=",
            "z3bqqqWcIZ6kZMXyxrF5IZQAFojGFI5g0qqTf1r9AW4=",
            "Bclk6zUm49f2XJkEF/nsVzSLc5/n3W8iyUQ3kwXXVdY=",
            "G2uZk1I9NBfxP/GYvdfgnioq8L1YWIQ9yRW024BzDxk=",
            "telYMXkcsoDc1dVTjCQB1aUlvJh833pHcUVdvJEXgRs=",
            "yINMt3ilG8rmc233fZptN6Qw1GwJBoFG934ou3KENQI=",
            "YFBpO3Uc29pXjJkqANg4l6QIbEZGNWrPMqE1NVbNZxM=",
            "x3vvGc0bOe8tAITwrGW5VyyyvpFxJnLfcUuRuU4P27M=",
            "BES9P6cW4Upe1BZhY9EVVbmWa6LGaexBSV2vpv9hHmQ=",
            "SaNb7Wc5G6VQhCwHSgUTizQiGHxlhQhLCGKYIrH9vV0=",
            "RSnjMF60gQG7nhJEuIa3DtAFB9gCSH4sEvOzSozCEKQ=",
            "aT4tDKbhpOHljsP0XXsCXNJHECmAzyfL5Kr12N53Oi0=",
            "DuDKZgq8xoKmHbR9w02ydRoHuA0qSyLCyEARx55OPJE=",
            "wvaoxvVlmz1TwlZ4uCwKNlBs6A9Mr5A1B1tqLfLZqNg=",
            "d2m50ooYpEFp38GOENUTVk0yFrpLSVnxvzYHi0Laue4=",
            "J3Mobdx7VA3lZXHb3guNrkXsKfGAtdJ1fkS1jz2B5ek=",
            "xLlEyeDEUaqDMb4zaoAqh1MplMmXeHVOBqdeDWw2QYs="
        ).map {
            Base64.decode(it)
        }.forEach { b ->
            testCurve25519(b)
        }

        // Generated by iOS
        listOf(
            "vin08/0YJDoGqXmK1hOVxqyfL39Ed/kfESAAwtKPazo=",
            "NTmqD74haDGINGczFZ+0FXzbltByXRJiOORpUar5U+w=",
            "gO7rkx7RbFNWphSSi4Y2eBR40iiENyxYz4PEDs05vng=",
            "ARl5XP4aoMqb+UsgUVhr8Hb6Zn2DHq1nNbhlqAYlGQY=",
            "cvPbNrgUBTrXxknUF1cvxCrWJ1KQqQQZeyt0q/ZQYhU="
        ).map {
            Base64.decode(it)
        }.forEach { b ->
            testCurve25519(b)
        }

        // Generated by go
        listOf(
            "CzR5czwYjf9HdbirZURqYO/sGeBP4OTRuiYUhg4CTLk=",
            "44RbiJjVMUM/JL+zxvtzICYsD2/R/MSGa+At2Ir4BfM=",
            "FzGgqvea39XAkX3Cb+EyiRmJ7O5N593Yc3F5NynGZ0A=",
            "knFRahCBkyXUDBILhDF21YtoTGQs1Ls73mHp81xixy8=",
            "CzR5czwYjf9HdbirZURqYO/sGeBP4OTRuiYUhg4CTLk="
        ).map {
            Base64.decode(it)
        }.forEach { b ->
            testCurve25519(b)
        }

        // Error keys
        listOf(
            "hD2ITLS6CXJhA5kw6cGndlXTxsE+51qnhrU4a0oJN8Q=",
            "qAtmWXeOnKHoklx3SEznKQumr2UMgY+sL0JnFBW9f6U=",
            "7Qpm/qyX/2YR4c5MUiTo0Ii3mAlG2ysrJUHcAed7epc="
        ).map {
            Base64.decode(it)
        }.forEach { b ->
            assert(!verifyPubkey(b))
        }
    }
}
